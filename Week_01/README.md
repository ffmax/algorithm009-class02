## 数组和链表的本质
最基础的数据结构无外乎数组和链表了，它们分别代表了连续空间和不连续空间的最基础的存储方式，连续存储快速但维护起来不灵活，不连续存储一般查询存储效率相对低，但维护代价不大。


对于**数组**而言，核心在于
1. 可以通过下标快速访问到对应下标元素，那么下标和下标元素之间的关系就是数组检索的关键，比如下标越大所存数据元素越大，这就是排序数组，
比如hash表，就是数据元素key经过hash映射构建与下标的关系。而这些下标元素可以直接被触达。
2. 由于计算机局部性，预取等因素，数组这种连续存储有较强的遍历的能力。

对于**链表**而言，它最核心的结构就是不仅存了数据项，还存了一个到达下一个元素的指针，那么它是不是可以存两个，就变成了二叉树，而且如果一个指向都比它大的，另一个指向都比它小的，是不是就变成了排序二叉树；反过来考虑，每个数据项都有对其他数据项的指针，检索问题就变成了留下那些对检索有帮助的指针，可以是比自身大的，可以是和自身相等的，比如二叉检索树，就是让左边连接的元素都比自生小，右边的元素都比自生大。再比如跳表每个数据都指向几个比自己大的元素。
其实在高级语言层面，数据的寻址方式只有数组的这种基址变址的方式，以及指针取值的方式，**所以总的来说其他数据结构都是这两种的扩展，以及相互组合**。hash表就是个很好的例子，先赋予key到下标一个1对1的单射关系:
> hash(key) = index

实现快速定位，然后把相同index对应的key用链表组织起来，解决冲突元素的维护问题，当然如果数据多了可以采用红黑树。而在解决hash冲突上引申下，布隆过滤器就是个通过多次hash（开放寻址）解决hash冲突的结构，所以可以认为hash表是单个函数的布隆过滤器，而位图可以看成，把映射留给上层调用去做，然后用这个数组存0-index的整形集合。

然后栈，队列，双端队列都是限制操作的线性结构，Abstract data type， 可用数组，链表去实现，不过从效率上看，数组无疑是最佳的实现方式，毕竟都是对头或者是尾部的
操作，可以避免掉数据元素大批量移动的开销，存储效率又高，无疑首选。
	